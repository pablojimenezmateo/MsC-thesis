\chapter{Routing algorithms}

In this chapter, well known routing algorithms are proposed and studied.

\section{What is a routing algorithm}

A routing algorithm is a deterministic program that finds a path between an origin and a destination. Usually the network where the path has to be extracted from is a graph, directed or undirected.

A basic graph has two main components, vertices and edges. In the context of this thesis, the vertices are traffic intersections and the edges are the roads that connect them.

Edges usually come with a weight, it is a value that represents the cost of traversing that edge, this could be anything from kilometers to time. Graphs can even have more than one kind of weight depending on what we intend to optimize.

In the context of this thesis, the roads have their length and the maximum allowed speed, this allows us to use the most simple metrics on traffic, time and distance.

A routing algorithm takes advantage of all this information and finds the minimum path depending on the metric we want to optimize, in our case time or distance.

In this thesis we are going to focus on the most simple yet effective path finding algorithms.

\subsection{Dijkstra's algorithm}

Dijskstra's algorithm is a well known iterative algorithm that finds the shortest path between two nodes in its most simple version. This is the most famous path finding algorithm and has been deeply studied \cite{dijkstra_1} \cite{dijkstra_2}.

Basically, this algorithm keeps a set with all the open nodes, in each iteration the node with the shortest distance to the starting path is studied, this node is removed from the set and all its neighbors are added to it if they are still to be studied. This process ends when we arrive to the desired node. 

\subsection{Bellman-Ford algorithm}

Bellman-Ford's algorithm is a well known variation of Dijkstra's algorithm that is worth mentioning, the main difference between those two algorithms is that Dijkstra cannot work with negative edges while Bellman-Ford can.

This feature is not interesting for this thesis so we will not go into further detail.

\subsection{A* algorithm}

A* is a variation of Dijkstra's algorithm commonly used in videogames. It uses a heuristic to estimate if the node to study looks promising, cutting the complexity time. This algorithm heavily relies on the heuristic function and does not guarantee the optimal path, that's why this algorithm has not been chosen.

\section{Chosen algorithms}

As detailed in the previous section, some algorithms have been studied to find the one that fits better in this simulator, I have chosen Dijkstra's because it always returns the optimal path, you can chose what to optimize (for example time or distance) and it can be easily modified.

\subsection{Shortest path algorithm}

The shortest path algorithm used in this simulator is the most basic implementation of Dijkstra's, knowing the distance between all the intersections the car finds its path looking for the one that takes less distance for it.

This method is deterministic, any car wanting to go from point A to point B will have the same path. Given the dynamic nature of the traffic, this will lead to significant traffic jams if the chosen path crosses a segment that congests very easily.

\subsection{Fastest path algorithm}

The fastest path algorithm is a slight modification of the previous algorithm, it only differs on searching for the minimum time instead of the minimum distance.

For each segment the maximum speed a car can drive on it is \[Speed_{max} = min(\text{max speed on that segment} | \text{max speed of the car})\]

Because the maximum speed of each car is different, different paths from A to B can be found, which makes this algorithm slightly better to avoid traffic jams. However, it does so by accident and many cars will chose the same path.

\subsection{Smart path algorithm}

The smart path algorithm takes into account the state of the traffic in real time and avoids congested paths. This is the proposed algorithm and it is expected to behave much better than the others.

Again, this algorithm is a modification of Dijkstra's algorithm that minimizes the time that takes the car from going to point A to B. This algorithm is very similar to the previous one, but it takes into account the \emph{current} maximum speed of that segment such that

\[Speed_{max} = min(\text{current max speed on that segment} | \text{max speed of the car})\]

so if a segment is congested the car simply avoids it. Because segments are dynamically congested, this algorithm recalculates its path at every intersection, given that you cannot turn around inside a segment this algorithm effectively keeps you in the fastest path at every moment.






